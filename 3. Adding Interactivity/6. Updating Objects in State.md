# Updating Objects in State

State can hold any kind of JavaScript value,
including objects.
But you shouldn’t change objects that
you hold in the React state directly.
Instead,
when you want to update an object,
you need to create a new one
(or make a copy of an existing one),
and then set the state to use that copy.

### You will learn

- How to correctly update an object in React state
- How to update a nested object without mutating it
- What immutability is, and how not to break it
- How to make object copying less repetitive with Immer

## What’s a mutation?

You can store any kind of JavaScript value in state.

```jsx
const [x, setX] = useState(0);
```

So far you’ve been working with numbers, strings, and booleans.
These kinds of JavaScript values are “immutable”,
meaning unchangeable or “read-only”.
You can trigger a re-render to replace a value:

```jsx
setX(5);
```

The x state changed from 0 to 5,
but the number 0 itself did not change.
It’s not possible to make any changes to the built-in primitive values like numbers, strings, and booleans in JavaScript.

Now consider an object in state:

```jsx
const [position, setPosition] = useState({ x: 0, y: 0 });
```

Technically,
it is possible to change the contents of the object itself.
This is called a mutation:

```jsx
position.x = 5;
```

However,
although objects in React state
are technically mutable,
you should treat them as
if they were immutable
—like numbers, booleans, and strings.
Instead of mutating them,
you should always replace them.

## Treat state as read-only

In other words,
you should <b>treat any JavaScript object that
you put into state as read-only.</b>

This example
holds an object in state
to represent the current pointer position.
The red dot is supposed to move
when you touch or move the cursor over the preview area.
But the dot stays in the initial position:

```jsx
// App.js
import { useState } from "react";
export default function MovingDot() {
  const [position, setPosition] = useState({
    x: 0,
    y: 0,
  });
  return (
    <div
      onPointerMove={(e) => {
        position.x = e.clientX;
        position.y = e.clientY;
      }}
      style={{
        position: "relative",
        width: "100vw",
        height: "100vh",
      }}
    >
      <div
        style={{
          position: "absolute",
          backgroundColor: "red",
          borderRadius: "50%",
          transform: `translate(${position.x}px, ${position.y}px)`,
          left: -10,
          top: -10,
          width: 20,
          height: 20,
        }}
      />
    </div>
  );
}
```
